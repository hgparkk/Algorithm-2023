# 알고리즘 설계 구현 결과 보고서: <선택문제 알고리즘>

## 가. 문제 정의
### 문제이름 : 숫자들 중에서 k번째로 작은 수 계산하기
### 문제설명 : 주어진 숫자를 중에서 k번째로 작은 수를 계산한다.
### 문제예시 : 5,4,6,2 중에서 2번째로 작은 숫자는 4이다.

## 나. 해결 아이디어
### 숫자들을 배열에 넣고, 배열 중에서 임의의 숫자를 고른 후, 고른 숫자를 기준으로 작은 숫자, 큰 숫자를 나누어 작은 숫자를 고른 숫자 왼편에, 큰 숫자를 고른 숫자 오른편에 둔다. 찾고자 하는 숫자보다 고른 숫자가 작으면 고른 숫자 왼편에서, 크면 고른 숫자 오른편에서 위 과정을 반복한다. 찾고자 하는 숫자가 고른 숫자면 고른 숫자를 반환한다.

## 다. 알고리즘
### 명칭: 선택문제 알고리즘 (Selection(A,left,right,k))
### 입력: 숫자들의 집합 (A[left]~A[right])
### 출력: k번째 작은 원소
### 처리순서:
#### if(left<right)
#### 	pivot <- rand(left~right)
#### 	swap(A[left],A[pivot])
#### 	L<-left+1
#### 	R<-right
#### 	p<-left+1
#### 	while (L<=R)
#### 		L=left+1
#### 		R=right
#### 		while(L<=right && A[L]<A[left])
#### 			L++
#### 		while(R>=left && A[R]>A[left])
#### 			R--
#### 		if(L<R)
#### 			swap(A[L],A[R])
#### 	while(p<=right && A[p]<A[left])
#### 		p++
#### 	p--
#### 	swap(A[left],A[p]);
#### 	S<-(p-1)-left+1
#### 	if(k<=S)
#### 		return Selection(A,left,p-1,k)
#### 	else if(k=S+1)
#### 		return A[p]
#### 	else
#### 		return Selection(A,p+1,right,k-S-1)

## 라. C코드 설계
### 1. 자료 구조 정의
#### - 숫자들의 집합 : A (int []) - 정수 배열
#### - k번째 작은 원소 : k (int) - 정수

### 2. 함수 정의
#### - 함수 기능 : 배열 중에서 랜덤하게 값을 고르고 고른 값보다 작은 수를 고른값 왼편에, 큰 수를 고른값 오른편에 둔다. 고른 값보다 k가 작으면 고른 값보다 작은 그룹, 크면 고른 값보다 큰 그룹에서 위 과정을 반복하고, 고른 값이 k이면 고른 값을 반환한다.
#### - 함수 프로토 타입 : int Selection(A,left,right,k)

## 마. 시험 계획
### 1. 테스트 케이스 설계
#### 임의의 숫자들의 집합 데이터 "data.txt" 를 읽어 숫자들을 배열에 저장한 다음 k번째 작은 수를 찾고 결과를 "result.txt"에 쓴다.
### 2. 테스트 환경
#### Visual Studio에서 컴파일 후 실행파일을 명령어 창(cmd)에서 실행한다.
